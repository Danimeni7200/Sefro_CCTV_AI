/**
 * Modern Electron App - License Plate Recognition System
 * Beautiful UI/UX with full functionality
 */

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

const state = {
  currentPage: 'dashboard',
  aiHost: localStorage.getItem('ai_host') || 'http://127.0.0.1:8000',
  refreshInterval: parseInt(localStorage.getItem('refreshInterval') || '3000'),
  resultsLimit: parseInt(localStorage.getItem('resultsLimit') || '50'),
  theme: localStorage.getItem('theme') || 'dark',
  results: [],
  cameras: new Set(),
  discoveredCameras: JSON.parse(localStorage.getItem('discoveredCameras') || '[]'),
  isConnected: false,
  currentPage: 'dashboard',
  autoRefreshTimer: null,
};

// ============================================================================
// INITIALIZATION
// ============================================================================

document.addEventListener('DOMContentLoaded', function() {

  initializeApp();
  setupEventListeners();
  applyTheme(state.theme);
  startAutoRefresh();
});

function initializeApp() {
  // Load initial data
  loadResults();
  checkConnection();
  
  // Set initial values
  document.getElementById('aiHostInput').value = state.aiHost;
  document.getElementById('refreshIntervalInput').value = state.refreshInterval / 1000;
  document.getElementById('resultsLimitInput').value = state.resultsLimit;
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function setupEventListeners() {
  // Navigation
  document.querySelectorAll('.nav-item').forEach(item => {
    item.addEventListener('click', (e) => {
      e.preventDefault();
      const page = item.dataset.page;
      navigateTo(page);
    });
  });

  // Header buttons
  document.getElementById('refreshBtn').addEventListener('click', () => {
    loadResults();
    showToast('Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯', 'success');
  });

  document.getElementById('notificationBtn').addEventListener('click', () => {
    showToast('3 Ø§Ø·Ù„Ø§Ø¹ Ø¬Ø¯ÛŒØ¯', 'info');
  });

  // Search
  document.getElementById('searchInput').addEventListener('input', (e) => {
    filterResults(e.target.value);
  });

  // Results page filters
  document.getElementById('plateSearch').addEventListener('input', (e) => {
    filterResultsTable(e.target.value);
  });

  document.getElementById('cameraFilter').addEventListener('change', (e) => {
    filterByCamera(e.target.value);
  });

  document.getElementById('dateFilter').addEventListener('change', (e) => {
    filterByDate(e.target.value);
  });

  document.getElementById('exportBtn').addEventListener('click', exportResults);

  // Settings
  document.getElementById('testConnectionBtn').addEventListener('click', testConnection);
  document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
  document.getElementById('resetSettingsBtn').addEventListener('click', resetSettings);

  // Theme selector
  document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const theme = btn.dataset.theme;
      setTheme(theme);
    });
  });

  // Discover form
  document.getElementById('discoverForm').addEventListener('submit', (e) => {
    e.preventDefault();
    performDiscover();
  });

  // Live stream page
  document.getElementById('goToDiscoverBtn').addEventListener('click', () => {
    navigateTo('discover');
  });

  // Modal
  document.getElementById('closeModalBtn').addEventListener('click', closeModal);
  document.getElementById('detailsModal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('detailsModal')) {
      closeModal();
    }
  });

  // Pagination
  document.getElementById('prevBtn').addEventListener('click', previousPage);
  document.getElementById('nextBtn').addEventListener('click', nextPage);
}

// ============================================================================
// NAVIGATION
// ============================================================================

function navigateTo(page) {
  // Hide all pages
  document.querySelectorAll('.page').forEach(p => p.style.display = 'none');
  
  // Show selected page
  const pageElement = document.getElementById(`${page}-page`);
  if (pageElement) {
    pageElement.style.display = 'block';
    pageElement.classList.add('active');
  }

  // Update nav items
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.remove('active');
    if (item.dataset.page === page) {
      item.classList.add('active');
    }
  });

  // Update header
  const titles = {
    dashboard: { title: 'Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯', subtitle: 'Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ Ø¨Ù‡ Ø³Ø§Ù…Ø§Ù†Ù‡ ØªØ´Ø®ÛŒØµ Ù¾Ù„Ø§Ú©' },
    results: { title: 'Ù†ØªØ§ÛŒØ¬', subtitle: 'Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÙ…Ø§Ù… Ù†ØªØ§ÛŒØ¬ ØªØ´Ø®ÛŒØµ Ø´Ø¯Ù‡' },
    settings: { title: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª', subtitle: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±Ù†Ø§Ù…Ù‡ Ùˆ Ø³Ø±ÙˆÛŒØ³' },
    discover: { title: 'Ú©Ø´Ù Ø¯ÙˆØ±Ø¨ÛŒÙ†', subtitle: 'Ú©Ø´Ù Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯ÙˆØ±Ø¨ÛŒÙ†â€ŒÙ‡Ø§ÛŒ RTSP' },
    livestream: { title: 'ğŸ‘ï¸ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø²Ù†Ø¯Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†â€ŒÙ‡Ø§', subtitle: 'Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†â€ŒÙ‡Ø§ÛŒ Ú©Ø´Ù Ø´Ø¯Ù‡' },
  };

  const pageInfo = titles[page] || titles.dashboard;
  document.getElementById('pageTitle').textContent = pageInfo.title;
  document.getElementById('pageSubtitle').textContent = pageInfo.subtitle;

  state.currentPage = page;

  // Load page-specific data
  if (page === 'results') {
    loadResultsTable();
  } else if (page === 'dashboard') {
    updateDashboard();
  } else if (page === 'livestream') {
    updateLiveStreamView();
  }
}

// ============================================================================
// DATA LOADING
// ============================================================================

async function loadResults() {
  try {
    const data = await window.lpr.fetchLatest(state.aiHost, state.resultsLimit);
    
    if (data && data.error) {
      // Check if it's a connection error (404 or network error)
      if (data.error.includes('404') || data.error.includes('fetch') || data.error.includes('network')) {
        showToast('Ø³Ø±ÙˆÛŒØ³ Ø§ØµÙ„ÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„ start-essential.bat Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯ ØªØ§ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´ÙˆÙ†Ø¯.', 'error');
      } else {
        showToast('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª: ' + data.error, 'error');
      }
      state.isConnected = false;
      updateConnectionStatus();
      return;
    }

    state.results = data || [];
    state.isConnected = true;
    updateConnectionStatus();

    // Extract unique cameras
    state.cameras.clear();
    state.results.forEach(r => {
      if (r.camera_id) state.cameras.add(r.camera_id);
    });

    // Update camera filter
    updateCameraFilter();

    // Update dashboard if on dashboard page
    if (state.currentPage === 'dashboard') {
      updateDashboard();
    }

    // Update results table if on results page
    if (state.currentPage === 'results') {
      loadResultsTable();
    }
  } catch (error) {
    console.error('Error loading results:', error);
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª. Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„ start-essential.bat Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯ ØªØ§ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´ÙˆÙ†Ø¯.', 'error');
    state.isConnected = false;
    updateConnectionStatus();
  }
}

function updateDashboard() {
  // Update stats
  document.getElementById('totalPlates').textContent = state.results.length;
  document.getElementById('activeCameras').textContent = state.cameras.size;
  
  // Calculate accuracy
  const avgConfidence = state.results.length > 0
    ? (state.results.reduce((sum, r) => sum + (r.confidence || 0), 0) / state.results.length * 100).toFixed(1)
    : 0;
  document.getElementById('accuracy').textContent = avgConfidence + '%';
  
  // Processing speed (mock)
  document.getElementById('processingSpeed').textContent = '45ms';

  // Update recent results
  updateRecentResults();

  // Draw charts
  drawDetectionChart();
  drawCameraChart();
}

function updateRecentResults() {
  const container = document.getElementById('recentResultsList');
  container.innerHTML = '';

  const recentResults = state.results.slice(0, 5);
  
  recentResults.forEach(result => {
    const item = document.createElement('div');
    item.className = 'result-item';
    
    const confidence = (result.confidence * 100).toFixed(1);
    const confidencePercent = Math.min(100, confidence);
    
    item.innerHTML = `
      <div class="result-info">
        <div class="result-plate">${result.plate_text || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</div>
        <div class="result-meta">
          <span><i class="fas fa-camera"></i> ${result.camera_id || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</span>
          <span><i class="fas fa-clock"></i> ${formatTime(result.timestamp)}</span>
        </div>
      </div>
      <div class="result-confidence">
        <div class="confidence-bar">
          <div class="confidence-fill" style="width: ${confidencePercent}%"></div>
        </div>
        <span>${confidence}%</span>
      </div>
    `;
    
    item.addEventListener('click', () => showResultDetails(result));
    container.appendChild(item);
  });
}

function loadResultsTable() {
  const tbody = document.getElementById('resultsTableBody');
  tbody.innerHTML = '';

  state.results.forEach(result => {
    const tr = document.createElement('tr');
    const confidence = (result.confidence * 100).toFixed(1);
    
    tr.innerHTML = `
      <td>${formatDateTime(result.timestamp)}</td>
      <td>${result.camera_id || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</td>
      <td><span class="plate-text">${result.plate_text || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</span></td>
      <td><span class="confidence-badge">${confidence}%</span></td>
      <td>
        <small>
          x: ${(result.bbox?.x || 0).toFixed(0)},
          y: ${(result.bbox?.y || 0).toFixed(0)},
          w: ${(result.bbox?.w || 0).toFixed(0)},
          h: ${(result.bbox?.h || 0).toFixed(0)}
        </small>
      </td>
      <td>
        <div class="action-buttons">
          <button class="btn-small" title="Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø²Ø¦ÛŒØ§Øª">
            <i class="fas fa-eye"></i>
          </button>
          <button class="btn-small" title="Ø¯Ø§Ù†Ù„ÙˆØ¯">
            <i class="fas fa-download"></i>
          </button>
        </div>
      </td>
    `;
    
    tr.querySelector('.btn-small').addEventListener('click', () => showResultDetails(result));
    tbody.appendChild(tr);
  });
}

// ============================================================================
// FILTERING
// ============================================================================

function filterResults(query) {
  if (!query) {
    updateRecentResults();
    return;
  }

  const filtered = state.results.filter(r => 
    r.plate_text?.includes(query) || 
    r.camera_id?.includes(query)
  );

  const container = document.getElementById('recentResultsList');
  container.innerHTML = '';

  filtered.slice(0, 5).forEach(result => {
    const item = document.createElement('div');
    item.className = 'result-item';
    
    const confidence = (result.confidence * 100).toFixed(1);
    const confidencePercent = Math.min(100, confidence);
    
    item.innerHTML = `
      <div class="result-info">
        <div class="result-plate">${result.plate_text || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</div>
        <div class="result-meta">
          <span><i class="fas fa-camera"></i> ${result.camera_id || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</span>
          <span><i class="fas fa-clock"></i> ${formatTime(result.timestamp)}</span>
        </div>
      </div>
      <div class="result-confidence">
        <div class="confidence-bar">
          <div class="confidence-fill" style="width: ${confidencePercent}%"></div>
        </div>
        <span>${confidence}%</span>
      </div>
    `;
    
    item.addEventListener('click', () => showResultDetails(result));
    container.appendChild(item);
  });
}

function filterResultsTable(query) {
  const tbody = document.getElementById('resultsTableBody');
  const rows = tbody.querySelectorAll('tr');

  rows.forEach(row => {
    const plateText = row.querySelector('.plate-text')?.textContent || '';
    const visible = plateText.includes(query) || query === '';
    row.style.display = visible ? '' : 'none';
  });
}

function filterByCamera(cameraId) {
  const tbody = document.getElementById('resultsTableBody');
  const rows = tbody.querySelectorAll('tr');

  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    const rowCameraId = cells[1]?.textContent || '';
    const visible = !cameraId || rowCameraId === cameraId;
    row.style.display = visible ? '' : 'none';
  });
}

function filterByDate(date) {
  if (!date) {
    loadResultsTable();
    return;
  }

  const tbody = document.getElementById('resultsTableBody');
  const rows = tbody.querySelectorAll('tr');

  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    const rowDate = cells[0]?.textContent?.split(' ')[0] || '';
    const visible = rowDate === date;
    row.style.display = visible ? '' : 'none';
  });
}

function updateCameraFilter() {
  const select = document.getElementById('cameraFilter');
  const currentValue = select.value;
  
  select.innerHTML = '<option value="">Ù‡Ù…Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†â€ŒÙ‡Ø§</option>';
  
  state.cameras.forEach(camera => {
    const option = document.createElement('option');
    option.value = camera;
    option.textContent = camera;
    select.appendChild(option);
  });

  select.value = currentValue;
}

// ============================================================================
// CHARTS
// ============================================================================

function drawDetectionChart() {
  const canvas = document.getElementById('detectionCanvas');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const width = canvas.parentElement.offsetWidth;
  const height = 300;
  
  canvas.width = width;
  canvas.height = height;

  // Mock data
  const data = [12, 19, 3, 5, 2, 3, 7, 15, 10, 8, 12, 14];
  const labels = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];

  // Draw bars
  const barWidth = width / data.length;
  const maxValue = Math.max(...data);
  const padding = 40;

  ctx.fillStyle = '#e5e7eb';
  ctx.font = '12px Vazirmatn';
  ctx.textAlign = 'center';

  data.forEach((value, index) => {
    const x = index * barWidth + barWidth / 2;
    const barHeight = (value / maxValue) * (height - padding * 2);
    const y = height - padding - barHeight;

    // Draw gradient bar
    const gradient = ctx.createLinearGradient(x - barWidth / 3, y, x - barWidth / 3, height - padding);
    gradient.addColorStop(0, '#667eea');
    gradient.addColorStop(1, '#764ba2');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x - barWidth / 3, y, barWidth * 0.6, barHeight);

    // Draw label
    ctx.fillStyle = '#9ca3af';
    ctx.fillText(labels[index], x, height - 10);
  });
}

function drawCameraChart() {
  const canvas = document.getElementById('cameraCanvas');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const width = canvas.parentElement.offsetWidth;
  const height = 300;
  
  canvas.width = width;
  canvas.height = height;

  // Mock data
  const cameras = Array.from(state.cameras).slice(0, 4);
  const data = cameras.map(() => Math.floor(Math.random() * 100) + 20);
  const colors = ['#667eea', '#764ba2', '#f5576c', '#43e97b'];

  // Draw pie chart
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 3;
  const total = data.reduce((a, b) => a + b, 0);

  let currentAngle = 0;

  data.forEach((value, index) => {
    const sliceAngle = (value / total) * Math.PI * 2;

    // Draw slice
    ctx.fillStyle = colors[index];
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
    ctx.closePath();
    ctx.fill();

    // Draw label
    const labelAngle = currentAngle + sliceAngle / 2;
    const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
    const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 12px Vazirmatn';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(((value / total) * 100).toFixed(0) + '%', labelX, labelY);

    currentAngle += sliceAngle;
  });
}

// ============================================================================
// SETTINGS
// ============================================================================

async function testConnection() {
  const host = document.getElementById('aiHostInput').value;
  const btn = document.getElementById('testConnectionBtn');
  
  btn.disabled = true;
  btn.innerHTML = '<i class="fas fa-spinner spin"></i> Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª...';

  try {
    const response = await fetch(`${host}/healthz`);
    if (response.ok) {
      showToast('Ø§ØªØµØ§Ù„ Ù…ÙˆÙÙ‚!', 'success');
      state.aiHost = host;
    } else {
      if (response.status === 404) {
        showToast('Ø³Ø±ÙˆÛŒØ³ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„ start-essential.bat Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯.', 'error');
      } else {
        showToast('Ø³Ø±ÙˆÛŒØ³ Ù¾Ø§Ø³Ø® Ù†Ø¯Ø§Ø¯. Ú©Ø¯ Ø®Ø·Ø§: ' + response.status, 'error');
      }
    }
  } catch (error) {
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„: Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„ start-essential.bat Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯. Ø®Ø·Ø§: ' + error.message, 'error');
  } finally {
    btn.disabled = false;
    btn.innerHTML = '<i class="fas fa-plug"></i> ØªØ³Øª Ø§ØªØµØ§Ù„';
  }
}

function saveSettings() {
  const host = document.getElementById('aiHostInput').value;
  const interval = parseInt(document.getElementById('refreshIntervalInput').value) * 1000;
  const limit = parseInt(document.getElementById('resultsLimitInput').value);

  localStorage.setItem('ai_host', host);
  localStorage.setItem('refreshInterval', interval);
  localStorage.setItem('resultsLimit', limit);

  state.aiHost = host;
  state.refreshInterval = interval;
  state.resultsLimit = limit;

  // Restart auto-refresh
  clearInterval(state.autoRefreshTimer);
  startAutoRefresh();

  showToast('ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯', 'success');
}

function resetSettings() {
  if (confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ')) {
    localStorage.clear();
    location.reload();
  }
}

// ============================================================================
// DISCOVER
// ============================================================================

async function performDiscover() {
  const ip = document.getElementById('discoverIp').value;
  const user = document.getElementById('discoverUser').value;
  const pass = document.getElementById('discoverPass').value;
  const brand = document.getElementById('discoverBrand').value;

  if (!ip || !user || !pass) {
    showToast('Ù„Ø·ÙØ§ ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø±Ø§ Ù¾Ø± Ú©Ù†ÛŒØ¯', 'warning');
    return;
  }

  const btn = document.querySelector('#discoverForm button');
  btn.disabled = true;
  btn.innerHTML = '<i class="fas fa-spinner spin"></i> Ø¯Ø± Ø­Ø§Ù„ Ú©Ø´Ù...';

  try {
    const result = await window.lpr.discover(ip, user, pass, brand);
    
    if (result && result.candidates && result.candidates.length > 0) {
      // Automatically add the FIRST discovered camera to live view (only one)
      // Check if this camera is already added
      const firstUrl = result.candidates[0];
      const alreadyAdded = state.discoveredCameras.some(c => c.url === firstUrl);
      
      if (!alreadyAdded) {
        addStreamToLiveView(firstUrl);
        showToast(`Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ù‡ Ù†Ù…Ø§ÛŒØ´ Ø²Ù†Ø¯Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯`, 'success');
      } else {
        showToast('Ø§ÛŒÙ† Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù‚Ø¨Ù„Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª', 'info');
      }
      
      // Automatically navigate to live stream tab after a short delay
      setTimeout(() => {
        navigateTo('livestream');
      }, 1500);
    } else {
      showToast('Ø¢Ø¯Ø±Ø³ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯', 'warning');
    }
  } catch (error) {
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ú©Ø´Ù: ' + error.message, 'error');
  } finally {
    btn.disabled = false;
    btn.innerHTML = '<i class="fas fa-search"></i> Ø´Ø±ÙˆØ¹ Ú©Ø´Ù';
  }
}

// Add stream to Python streaming service
async function addStreamToPythonService(streamId, rtspUrl, enableAI = true) {
  try {
    const response = await fetch(`http://127.0.0.1:8088/add_stream?stream_id=${streamId}&rtsp_url=${encodeURIComponent(rtspUrl)}&enable_ai=${enableAI}`, {
      method: 'POST'
    });
    
    if (!response.ok) {
      // If the endpoint doesn't exist, just log it and continue
      if (response.status === 404) {
        console.log('Python streaming service endpoint not available, continuing without it');
        return;
      }
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.message || 'Failed to add stream');
    }
    
    console.log('Stream added to Python service:', streamId);
    return true;
  } catch (error) {
    console.error('Error adding stream to Python service:', error);
    // Don't show error toast for 404 errors since it's expected when streaming service is not available
    if (error.message !== 'HTTP 404') {
      showToast('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¬Ø±ÛŒØ§Ù†: ' + error.message, 'error');
    }
    return false;
  }
}

// Add stream to live view
function addStreamToLiveView(url) {
  // Generate a unique ID for the stream
  const streamId = 'stream_' + Date.now();
  
  // Extract camera info from URL
  const cameraInfo = {
    id: streamId,
    url: url,
    name: extractCameraName(url),
    addedAt: new Date().toISOString()
  };

  // Add to discovered cameras
  state.discoveredCameras.push(cameraInfo);
  localStorage.setItem('discoveredCameras', JSON.stringify(state.discoveredCameras));

  // Add stream to Python service
  addStreamToPythonService(streamId, url, true).then(success => {
    if (success) {
      showToast('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ù‡ Ù†Ù…Ø§ÛŒØ´ Ø²Ù†Ø¯Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯', 'success');
    } else {
      showToast('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯ Ø§Ù…Ø§ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ø§ Ù…Ø´Ú©Ù„ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯', 'warning');
    }
  });

  // If we're on the live stream page, update the view
  if (state.currentPage === 'livestream') {
    updateLiveStreamView();
  }
}

// Helper function to format time in Persian
function formatTime(dateString) {
  try {
    const date = new Date(dateString);
    return date.toLocaleTimeString('fa-IR', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  } catch (error) {
    return 'Ù†Ø§Ù…Ø´Ø®Øµ';
  }
}

// Extract camera name from URL
function extractCameraName(url) {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (e) {
    return 'Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù†Ø§Ù…Ø´Ø®Øµ';
  }
}

// Update live stream view
function updateLiveStreamView() {
  console.log('Updating live stream view with', state.discoveredCameras.length, 'cameras');
  
  const emptyState = document.getElementById('livestreamEmptyState');
  const streamGrid = document.getElementById('livestreamGrid');

  if (state.discoveredCameras.length === 0) {
    console.log('No cameras found, showing empty state');
    emptyState.style.display = 'flex';
    streamGrid.style.display = 'none';
    return;
  }

  console.log('Showing stream grid with cameras');
  emptyState.style.display = 'none';
  streamGrid.style.display = 'grid';
  streamGrid.innerHTML = '';

  state.discoveredCameras.forEach((camera, index) => {
    console.log('Adding camera to stream grid:', camera);
    
    const streamItem = document.createElement('div');
    streamItem.className = 'stream-item';
    streamItem.innerHTML = `
      <div class="stream-header">
        <h4><i class="fas fa-camera"></i> ${camera.name}</h4>
        <div class="stream-header-actions">
          <button class="btn-small" onclick="toggleFullscreenStream('${camera.id}')" title="ØªÙ…Ø§Ù… ØµÙØ­Ù‡">
            <i class="fas fa-expand"></i>
          </button>
          <button class="btn-small" onclick="removeStream('${camera.id}')" title="Ø­Ø°Ù Ø¯ÙˆØ±Ø¨ÛŒÙ†">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>
      <div class="stream-video-container">
        <div class="stream-video-wrapper">
          <!-- Canvas element for live stream -->
          <canvas id="stream-${camera.id}" class="live-stream-canvas"></canvas>
          <div id="stream-placeholder-${camera.id}" class="stream-placeholder">
            <i class="fas fa-video"></i>
            <p>Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡...</p>
            <small>Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ "Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù†" Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</small>
          </div>
        </div>
      </div>
      <div class="stream-controls">
        <div class="control-group">
          <button class="btn btn-primary" onclick="startStream('${camera.id}', '${camera.url}')" title="Ø´Ø±ÙˆØ¹ Ù†Ù…Ø§ÛŒØ´ Ø²Ù†Ø¯Ù‡">
            <i class="fas fa-play"></i> Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù†
          </button>
          <button class="btn btn-secondary" onclick="stopStream('${camera.id}')" title="ØªÙˆÙ‚Ù Ù†Ù…Ø§ÛŒØ´ Ø²Ù†Ø¯Ù‡">
            <i class="fas fa-stop"></i> ØªÙˆÙ‚Ù Ø¬Ø±ÛŒØ§Ù†
          </button>
        </div>
        <div class="control-group">
          <button class="btn btn-secondary" onclick="captureSnapshot('${camera.id}')" title="Ø«Ø¨Øª Ø¹Ú©Ø³">
            <i class="fas fa-camera"></i> Ø«Ø¨Øª Ø¹Ú©Ø³
          </button>
          <button class="btn btn-secondary" onclick="showStreamInfo('${camera.id}')" title="Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬Ø±ÛŒØ§Ù†">
            <i class="fas fa-info-circle"></i> Ø§Ø·Ù„Ø§Ø¹Ø§Øª
          </button>
        </div>
      </div>
      <div class="stream-info">
        <span id="stream-status-${camera.id}" class="status-indicator">Ø¢Ù…Ø§Ø¯Ù‡</span>
        <span><i class="far fa-clock"></i> Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: ${formatTime(camera.addedAt)}</span>
      </div>
    `;
    streamGrid.appendChild(streamItem);
  });
  
  console.log('Finished updating live stream view');
}

// Start streaming for a camera
async function startStream(cameraId, rtspUrl) {
  console.log('Starting stream for camera:', cameraId);
  
  try {
    // Check if streaming service is available first
    const serviceAvailable = await checkStreamingService();
    if (!serviceAvailable) {
      showToast('Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ù‡ Ø³Ø±ÙˆÛŒØ³ local_app Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§Ø³Øª.', 'error');
      
      // Update status indicator to show service error
      const statusIndicator = document.getElementById(`stream-status-${cameraId}`);
      if (statusIndicator) {
        statusIndicator.textContent = 'Ø³Ø±ÙˆÛŒØ³ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª';
        statusIndicator.className = 'status-indicator warning';
      }
      
      // Show help dialog
      showServiceHelp();
      
      return;
    }
    
    const placeholder = document.getElementById(`stream-placeholder-${cameraId}`);
    const canvasElement = document.getElementById(`stream-${cameraId}`);
    const statusIndicator = document.getElementById(`stream-status-${cameraId}`);
    
    // Check if elements exist
    if (!placeholder || !canvasElement || !statusIndicator) {
      console.error('Could not find stream elements for camera:', cameraId);
      showToast('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡', 'error');
      return;
    }
    
    console.log('Found all elements for camera:', cameraId);
    
    // Hide placeholder and show canvas element
    placeholder.style.display = 'none';
    canvasElement.style.display = 'block';
    canvasElement.classList.add('streaming'); // Add streaming class for visual effect
    statusIndicator.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„...';
    statusIndicator.className = 'status-indicator';
    
    console.log('Updated UI elements for camera:', cameraId);
    
    // Start live stream using canvas
    startLiveStream(cameraId, rtspUrl);
    
    showToast('Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡...', 'info');
  } catch (error) {
    console.error('Error starting stream:', error);
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡: ' + error.message, 'error');
  }
}

// Stop streaming for a camera
function stopStream(cameraId) {
  console.log('Stopping stream for camera:', cameraId);
  
  try {
    const placeholder = document.getElementById(`stream-placeholder-${cameraId}`);
    const canvasElement = document.getElementById(`stream-${cameraId}`);
    const statusIndicator = document.getElementById(`stream-status-${cameraId}`);
    
    // Check if elements exist
    if (!placeholder || !canvasElement || !statusIndicator) {
      console.error('Could not find stream elements for camera:', cameraId);
      showToast('Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ‚Ù Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡', 'error');
      return;
    }
    
    // Show placeholder and hide canvas element
    placeholder.style.display = 'flex';
    canvasElement.style.display = 'none';
    canvasElement.classList.remove('streaming'); // Remove streaming class
    
    // Update status indicator
    statusIndicator.textContent = 'Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡';
    statusIndicator.className = 'status-indicator';
    
    // Stop the stream animation frame
    if (state.streamIntervals && state.streamIntervals[cameraId]) {
      if (state.streamIntervals[cameraId].animationFrameId) {
        cancelAnimationFrame(state.streamIntervals[cameraId].animationFrameId);
      }
      delete state.streamIntervals[cameraId];
    }
    
    // Remove resize handler
    if (state.streamCleanup && state.streamCleanup[cameraId]) {
      window.removeEventListener('resize', state.streamCleanup[cameraId].resizeHandler);
      delete state.streamCleanup[cameraId];
    }
    
    // Clear canvas
    const ctx = canvasElement.getContext('2d');
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    // Remove image reference
    delete canvasElement.currentImage;
    
    // Reset stream added flag so it can be restarted if needed
    if (window.streamAddedFlags) {
      delete window.streamAddedFlags[cameraId];
    }
    
    // Reset service check attempts
    // This is a global counter, but we'll reset it when all streams are stopped
    let activeStreams = Object.keys(state.streamIntervals || {}).length;
    if (activeStreams === 0 && typeof window !== 'undefined') {
      // Reset service check attempts when no streams are active
      window.serviceCheckAttempts = 0;
    }
    
    showToast('ØªÙˆÙ‚Ù Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡', 'info');
  } catch (error) {
    console.error('Error stopping stream:', error);
    showToast('Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ‚Ù Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡: ' + error.message, 'error');
  }
}

// Start live stream using canvas for smoother playback
async function startLiveStream(cameraId, rtspUrl) {
  console.log('Starting live stream for camera:', cameraId, 'from', rtspUrl);
  
  try {
    const canvasElement = document.getElementById(`stream-${cameraId}`);
    const statusIndicator = document.getElementById(`stream-status-${cameraId}`);
    
    // Check if element exists
    if (!canvasElement) {
      console.error('Could not find canvas element for camera:', cameraId);
      return;
    }
    
    // Get 2D context for drawing
    const ctx = canvasElement.getContext('2d');
    
    // Store resize handler for cleanup
    const resizeHandler = () => {
      // Redraw current frame if available
      if (canvasElement.currentImage) {
        const img = canvasElement.currentImage;
        const container = canvasElement.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        // Calculate aspect ratio
        const aspectRatio = img.width / img.height;
        let drawWidth, drawHeight, drawX, drawY;
        
        if (containerWidth / containerHeight > aspectRatio) {
          // Container is wider than image aspect ratio
          drawHeight = containerHeight;
          drawWidth = containerHeight * aspectRatio;
          drawX = (containerWidth - drawWidth) / 2;
          drawY = 0;
        } else {
          // Container is taller than image aspect ratio
          drawWidth = containerWidth;
          drawHeight = containerWidth / aspectRatio;
          drawX = 0;
          drawY = (containerHeight - drawHeight) / 2;
        }
        
        // Set canvas dimensions to match container
        canvasElement.width = containerWidth;
        canvasElement.height = containerHeight;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // Draw image on canvas with proper aspect ratio
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
      }
    };
    
    // Add resize listener
    window.addEventListener('resize', resizeHandler);
    
    // Initialize stream intervals object if it doesn't exist
    if (!state.streamIntervals) {
      state.streamIntervals = {};
    }
    
    // Store cleanup function
    if (!state.streamCleanup) {
      state.streamCleanup = {};
    }
    
    // Store resize handler for cleanup
    state.streamCleanup[cameraId] = {
      resizeHandler: resizeHandler
    };
    
    // Clear any existing interval for this camera
    if (state.streamIntervals[cameraId]) {
      if (state.streamIntervals[cameraId].animationFrameId) {
        cancelAnimationFrame(state.streamIntervals[cameraId].animationFrameId);
      }
      delete state.streamIntervals[cameraId];
    }
    
    // Track connection state
    let connectionFailures = 0;
    const maxConnectionFailures = 5; // Reduced to prevent infinite loops
    let lastFrameTime = Date.now();
    const frameTimeout = 8000; // 8 seconds timeout
    
    // Service availability tracking
    let serviceCheckAttempts = 0;
    const maxServiceCheckAttempts = 3;
    
    // Add stream to Python service only once per session
    window.streamAddedFlags = window.streamAddedFlags || {};
    let streamAdded = window.streamAddedFlags[cameraId] || false;
    
    // Track pending requests to prevent overlapping
    let pendingRequest = false;
    
    // Implement adaptive streaming based on performance
    let frameTimes = [];
    let targetFrameRate = 15; // Start with 15 FPS for better stability
    let lastFrameProcessTime = 0;
    
    // Fetch actual frame from Python service
    const fetchFrame = async () => {
      // Prevent overlapping requests
      if (pendingRequest) {
        return;
      }
      
      // Rate limiting based on target frame rate
      const now = Date.now();
      const minInterval = 1000 / targetFrameRate;
      if (now - lastFrameProcessTime < minInterval) {
        return;
      }
      
      try {
        pendingRequest = true;
        
        // Add the stream to Python service only once
        if (!streamAdded) {
          console.log('Adding stream to Python service:', cameraId);
          
          // First check if service is available
          const serviceAvailable = await checkStreamingService();
          if (!serviceAvailable) {
            serviceCheckAttempts++;
            if (serviceCheckAttempts >= maxServiceCheckAttempts) {
              throw new Error('Service unavailable after multiple attempts');
            }
          }
          
          // Try to add stream with AI disabled for better stability
          const result = await addStreamToPythonService(cameraId, rtspUrl, false);
          
          if (result.success) {
            console.log('Added stream to Python service:', result.data);
            
            // Mark stream as added (even if it already exists)
            streamAdded = true;
            window.streamAddedFlags[cameraId] = true;
            
            // Update status to show connecting
            if (statusIndicator) {
              statusIndicator.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„...';
              statusIndicator.className = 'status-indicator';
            }
          } else {
            console.error('Failed to add stream to Python service:', result.error);
            serviceCheckAttempts++;
            
            if (serviceCheckAttempts >= maxServiceCheckAttempts) {
              throw new Error(`Failed to add stream: ${result.error}`);
            }
          }
        }
        
        // Then fetch frames from the stream endpoint
        const timestamp = Date.now();
        const frameUrl = `http://127.0.0.1:8088/stream/${cameraId}/frame?t=${timestamp}`;
        
        // Fetch the image as blob with longer timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch(frameUrl, { 
          signal: controller.signal,
          cache: 'no-cache',
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        
        // Create image object to draw on canvas
        const img = new Image();
        img.onload = () => {
          // Update last frame time
          lastFrameTime = Date.now();
          
          // Calculate frame processing time for adaptive streaming
          const processTime = lastFrameTime - now;
          frameTimes.push(processTime);
          if (frameTimes.length > 10) {
            frameTimes.shift(); // Keep only last 10 measurements
          }
          
          // Adjust frame rate based on performance
          if (frameTimes.length >= 5) {
            const avgProcessTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
            if (avgProcessTime > 200 && targetFrameRate > 5) {
              // Reduce frame rate if processing is slow
              targetFrameRate = Math.max(5, targetFrameRate - 2);
              console.log('Reducing frame rate to:', targetFrameRate);
            } else if (avgProcessTime < 100 && targetFrameRate < 15) {
              // Increase frame rate if processing is fast
              targetFrameRate = Math.min(15, targetFrameRate + 2);
              console.log('Increasing frame rate to:', targetFrameRate);
            }
          }
          
          // Update status indicator to show active
          if (statusIndicator) {
            statusIndicator.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø®Ø´';
            statusIndicator.className = 'status-indicator connected';
          }
          
          // Store image reference for resize handling
          canvasElement.currentImage = img;
          
          // Set canvas dimensions to match container while maintaining aspect ratio
          const container = canvasElement.parentElement;
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          
          // Calculate aspect ratio
          const aspectRatio = img.width / img.height;
          let drawWidth, drawHeight, drawX, drawY;
          
          if (containerWidth / containerHeight > aspectRatio) {
            // Container is wider than image aspect ratio
            drawHeight = containerHeight;
            drawWidth = containerHeight * aspectRatio;
            drawX = (containerWidth - drawWidth) / 2;
            drawY = 0;
          } else {
            // Container is taller than image aspect ratio
            drawWidth = containerWidth;
            drawHeight = containerWidth / aspectRatio;
            drawX = 0;
            drawY = (containerHeight - drawHeight) / 2;
          }
          
          // Set canvas dimensions to match container
          canvasElement.width = containerWidth;
          canvasElement.height = containerHeight;
          
          // Clear canvas
          ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
          
          // Draw image on canvas with proper aspect ratio
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
          
          // Clean up object URL
          URL.revokeObjectURL(imageUrl);
          
          // Reset connection failures on successful load
          connectionFailures = 0;
          serviceCheckAttempts = 0; // Reset service check attempts on success
          lastFrameProcessTime = Date.now();
          console.log('Frame loaded and drawn successfully');
          
          // Release pending request flag
          pendingRequest = false;
        };
        
        img.onerror = (event) => {
          console.error('Failed to load frame image:', event);
          URL.revokeObjectURL(imageUrl);
          connectionFailures++;
          
          // Check if we haven't received a frame in a while
          const timeSinceLastFrame = Date.now() - lastFrameTime;
          if (timeSinceLastFrame > frameTimeout) {
            console.warn(`No frames received for ${timeSinceLastFrame}ms, treating as connection failure`);
            connectionFailures += 2; // Treat as multiple failures
            // Update status indicator to show problem
            if (statusIndicator) {
              statusIndicator.textContent = 'Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„';
              statusIndicator.className = 'status-indicator warning';
            }
          }
          
          // Release pending request flag
          pendingRequest = false;
          
          // If we have too many connection failures, stop the stream
          if (connectionFailures >= maxConnectionFailures) {
            console.error('Too many connection failures, stopping stream');
            // Update status indicator to show error
            if (statusIndicator) {
              statusIndicator.textContent = 'Ù‚Ø·Ø¹ Ø´Ø¯Ù‡';
              statusIndicator.className = 'status-indicator error';
            }
            stopStream(cameraId);
            showToast('Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù‚Ø·Ø¹ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§ØªØµØ§Ù„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.', 'error');
            return;
          }
        };
        
        img.src = imageUrl;
        
        console.log('Fetching frame from:', frameUrl);
      } catch (error) {
        // Release pending request flag
        pendingRequest = false;
        
        // Don't count abort errors as connection failures
        if (error.name !== 'AbortError') {
          console.error('Error fetching stream frame:', error);
          connectionFailures++;
          
          // Special handling for connection refused errors
          if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('Connection refused'))) {
            console.error('Connection to streaming service failed. Service may be down.');
            serviceCheckAttempts++;
            
            // Update status indicator to show service error
            if (statusIndicator) {
              statusIndicator.textContent = 'Ø³Ø±ÙˆÛŒØ³ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª';
              statusIndicator.className = 'status-indicator error';
            }
            
            // Show user-friendly error message once per session
            if (serviceCheckAttempts === 1) {
              showToast('Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ± Ø¨Ø±Ù‚Ø±Ø§Ø± Ù†Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ù‡ Ø³Ø±ÙˆÛŒØ³ local_app Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§Ø³Øª.', 'error');
            }
            
            // If we've tried enough times, stop the stream to prevent infinite retries
            if (serviceCheckAttempts >= maxServiceCheckAttempts) {
              stopStream(cameraId);
              return;
            }
          }
        } else {
          console.warn('Request aborted, not counting as failure');
          return; // Don't process abort errors further
        }
        
        // Check if we haven't received a frame in a while
        const timeSinceLastFrame = Date.now() - lastFrameTime;
        if (timeSinceLastFrame > frameTimeout) {
          console.warn(`No frames received for ${timeSinceLastFrame}ms, treating as connection failure`);
          connectionFailures += 2; // Treat as multiple failures
          // Update status indicator to show problem
          if (statusIndicator) {
            statusIndicator.textContent = 'Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„';
            statusIndicator.className = 'status-indicator warning';
          }
        }
        
        // If we have too many connection failures, stop the stream
        if (connectionFailures >= maxConnectionFailures) {
          console.error('Too many connection failures, stopping stream');
          // Update status indicator to show error
          if (statusIndicator) {
            statusIndicator.textContent = 'Ù‚Ø·Ø¹ Ø´Ø¯Ù‡';
            statusIndicator.className = 'status-indicator error';
          }
          stopStream(cameraId);
          showToast('Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù‚Ø·Ø¹ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§ØªØµØ§Ù„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.', 'error');
          return;
        }
      }
    };
    
    // Use adaptive streaming with requestAnimationFrame but with rate limiting
    let lastFetchTime = 0;
    const minFetchInterval = 150; // Minimum 150ms between fetches for stability
    
    const updateStream = () => {
      const now = Date.now();
      if (now - lastFetchTime >= minFetchInterval) {
        fetchFrame();
        lastFetchTime = now;
      }
      
      // Continue the loop only if the stream interval still exists
      if (state.streamIntervals[cameraId]) {
        state.streamIntervals[cameraId].animationFrameId = requestAnimationFrame(updateStream);
      }
    };
    
    // Start the streaming loop
    state.streamIntervals[cameraId] = { animationFrameId: requestAnimationFrame(updateStream) };
    
    console.log('Started live stream for camera:', cameraId);
  } catch (error) {
    console.error('Error starting live stream:', error);
    // Update status indicator to show error
    const statusIndicator = document.getElementById(`stream-status-${cameraId}`);
    if (statusIndicator) {
      statusIndicator.textContent = 'Ø®Ø·Ø§';
      statusIndicator.className = 'status-indicator error';
    }
    
    // Show user-friendly error message
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¬Ø±ÛŒØ§Ù† Ø²Ù†Ø¯Ù‡: ' + error.message, 'error');
  }
}

// ============================================================================
// CONNECTION STATUS
// ============================================================================

function checkConnection() {
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');

  if (state.isConnected) {
    statusDot.classList.add('connected');
    statusText.textContent = 'Ù…ØªØµÙ„';
  } else {
    statusDot.classList.remove('connected');
    statusText.textContent = 'Ù‚Ø·Ø¹ Ø´Ø¯Ù‡';
  }
}

function updateConnectionStatus() {
  checkConnection();
}

// ============================================================================
// THEME
// ============================================================================

function setTheme(theme) {
  state.theme = theme;
  localStorage.setItem('theme', theme);
  applyTheme(theme);

  // Update theme buttons
  document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.theme === theme) {
      btn.classList.add('active');
    }
  });
}

function applyTheme(theme) {
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }
}

// ============================================================================
// MODAL
// ============================================================================

function showResultDetails(result) {
  const modal = document.getElementById('detailsModal');
  const body = document.getElementById('modalBody');

  const confidence = (result.confidence * 100).toFixed(2);

  body.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div>
        <h4 style="color: var(--text-secondary); margin-bottom: 0.5rem;">Ù¾Ù„Ø§Ú©</h4>
        <p style="font-size: 1.5rem; font-weight: 700; color: var(--primary); font-family: 'Courier New', monospace;">
          ${result.plate_text || 'Ù†Ø§Ù…Ø´Ø®Øµ'}
        </p>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
        <div>
          <h4 style="color: var(--text-secondary); margin-bottom: 0.5rem;">Ø¯ÙˆØ±Ø¨ÛŒÙ†</h4>
          <p>${result.camera_id || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</p>
        </div>
        <div>
          <h4 style="color: var(--text-secondary); margin-bottom: 0.5rem;">Ø²Ù…Ø§Ù†</h4>
          <p>${formatDateTime(result.timestamp)}</p>
        </div>
      </div>
      <div>
        <h4 style="color: var(--text-secondary); margin-bottom: 0.5rem;">Ø§Ø·Ù…ÛŒÙ†Ø§Ù†</h4>
        <div style="display: flex; align-items: center; gap: 1rem;">
          <div style="flex: 1; height: 8px; background: var(--bg-hover); border-radius: 4px; overflow: hidden;">
            <div style="height: 100%; width: ${confidence}%; background: linear-gradient(90deg, var(--primary), var(--secondary));"></div>
          </div>
          <span style="font-weight: 700;">${confidence}%</span>
        </div>
      </div>
      <div>
        <h4 style="color: var(--text-secondary); margin-bottom: 0.5rem;"> Ù…ÙˆÙ‚Ø¹ÛŒØª (Bounding Box)</h4>
        <p style="font-family: 'Courier New', monospace; font-size: 0.875rem;">
          X: ${(result.bbox?.x || 0).toFixed(2)}<br>
          Y: ${(result.bbox?.y || 0).toFixed(2)}<br>
          Width: ${(result.bbox?.w || 0).toFixed(2)}<br>
          Height: ${(result.bbox?.h || 0).toFixed(2)}
        </p>
      </div>
    </div>
  `;

  modal.classList.add('active');
}

function closeModal() {
  document.getElementById('detailsModal').classList.remove('active');
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

function showToast(message, type = 'info') {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;

  const icons = {
    success: 'fa-check-circle',
    error: 'fa-exclamation-circle',
    warning: 'fa-exclamation-triangle',
    info: 'fa-info-circle',
  };

  toast.innerHTML = `
    <i class="fas ${icons[type]} toast-icon"></i>
    <span class="toast-message">${message}</span>
    <button class="toast-close">&times;</button>
  `;

  container.appendChild(toast);

  const closeBtn = toast.querySelector('.toast-close');
  closeBtn.addEventListener('click', () => {
    toast.remove();
  });

  setTimeout(() => {
    toast.remove();
  }, 4000);
}

// ============================================================================
// EXPORT
// ============================================================================

function exportResults() {
  const csv = convertToCSV(state.results);
  downloadCSV(csv, 'license_plate_results.csv');
  showToast('Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´Ø±ÙˆØ¹ Ø´Ø¯', 'success');
}

function convertToCSV(data) {
  const headers = ['Ø²Ù…Ø§Ù†', 'Ø¯ÙˆØ±Ø¨ÛŒÙ†', 'Ù¾Ù„Ø§Ú©', 'Ø§Ø·Ù…ÛŒÙ†Ø§Ù†', 'X', 'Y', 'Width', 'Height'];
  const rows = data.map(r => [
    formatDateTime(r.timestamp),
    r.camera_id || '',
    r.plate_text || '',
    (r.confidence * 100).toFixed(2),
    (r.bbox?.x || 0).toFixed(2),
    (r.bbox?.y || 0).toFixed(2),
    (r.bbox?.w || 0).toFixed(2),
    (r.bbox?.h || 0).toFixed(2),
  ]);

  let csv = headers.join(',') + '\n';
  rows.forEach(row => {
    csv += row.map(cell => `"${cell}"`).join(',') + '\n';
  });

  return csv;
}

function downloadCSV(csv, filename) {
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// ============================================================================
// PAGINATION
// ============================================================================

let currentPage = 1;
const itemsPerPage = 20;

function previousPage() {
  if (currentPage > 1) {
    currentPage--;
    loadResultsTable();
    updatePaginationInfo();
  }
}

function nextPage() {
  const maxPage = Math.ceil(state.results.length / itemsPerPage);
  if (currentPage < maxPage) {
    currentPage++;
    loadResultsTable();
    updatePaginationInfo();
  }
}

function updatePaginationInfo() {
  const maxPage = Math.ceil(state.results.length / itemsPerPage);
  document.getElementById('paginationInfo').textContent = `ØµÙØ­Ù‡ ${currentPage} Ø§Ø² ${maxPage}`;
  
  document.getElementById('prevBtn').disabled = currentPage === 1;
  document.getElementById('nextBtn').disabled = currentPage === maxPage;
}

// ============================================================================
// AUTO REFRESH
// ============================================================================

function startAutoRefresh() {
  state.autoRefreshTimer = setInterval(() => {
    loadResults();
  }, state.refreshInterval);
}

// ============================================================================
// UTILITIES
// ============================================================================

// Check if streaming service is available
async function checkStreamingService() {
  try {
    // Add a longer delay to prevent overwhelming the service
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const controller = new AbortController();
    // Increased timeout to 10 seconds
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    const response = await fetch('http://127.0.0.1:8088/health', { 
      method: 'GET',
      signal: controller.signal,
      timeout: 10000,
    });
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      return false;
// Check if streaming service is available
async function checkStreamingService() {
  try {
    // Add a longer delay to prevent overwhelming the service
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const controller = new AbortController();
    // Increased timeout to 10 seconds
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    const response = await fetch('http://127.0.0.1:8088/health', { 
      method: 'GET',
      signal: controller.signal,
      // Add headers to prevent caching issues
      headers: {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache'
      }
    });
    
    clearTimeout(timeoutId);
    
    if (response.ok) {
      const data = await response.json();
      console.log('Streaming service is available:', data);
      return true;
    } else {
      console.error('Streaming service returned error status:', response.status, await response.text());
      return false;
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Streaming service health check timed out');
    } else {
      console.error('Streaming service is not available:', error);
    }
    return false;
  }
}

// Add stream to Python service
async function addStreamToPythonService(streamId, rtspUrl, enableAI = false) {
  console.log('Adding stream to Python service:', streamId, rtspUrl, enableAI);
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
    
    // Updated URL to match what the Python service expects
    // Changed enable_ai parameter to match Python service expectation
    const addStreamUrl = `http://127.0.0.1:8088/add_stream?stream_id=${streamId}&rtsp_url=${encodeURIComponent(rtspUrl)}&enable_ai=${enableAI}`;
    
    const response = await fetch(addStreamUrl, { 
      method: 'POST',
      signal: controller.signal,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      // Add body even if empty to ensure proper request format
      body: JSON.stringify({})
    });
    
    clearTimeout(timeoutId);
    
    if (response.ok) {
      const result = await response.json();
      console.log('Successfully added stream to Python service:', result);
      return { success: true, data: result };
    } else {
      const errorText = await response.text();
      console.error('Failed to add stream to Python service:', response.status, errorText);
      
      // Handle specific error codes
      if (response.status === 400) {
        showToast('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ†: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø´ØªØ¨Ø§Ù‡ ÛŒØ§ Ø¢Ø¯Ø±Ø³ RTSP Ù†Ø§Ù…Ø¹ØªØ¨Ø±', 'error');
      } else if (response.status === 500) {
        showToast('Ø®Ø·Ø§ Ø¯Ø± Ø³Ø±ÙˆØ±: Ù…Ø´Ú©Ù„ Ø¯Ø§Ø®Ù„ÛŒ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯ÙˆØ±Ø¨ÛŒÙ†', 'error');
      } else {
        showToast(`Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ†: HTTP ${response.status}`, 'error');
      }
      
      return { success: false, error: `HTTP ${response.status}: ${errorText}` };
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Request to add stream timed out');
      showToast('Ø²Ù…Ø§Ù† Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯. Ø³Ø±ÙˆÛŒØ³ Ù¾Ø§Ø³Ø® Ù†Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.', 'error');
    } else {
      console.error('Error adding stream to Python service:', error);
      showToast('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ†: ' + error.message, 'error');
    }
    return { success: false, error: error.message };
  }
}

// Show help dialog for starting required services
function showServiceHelp() {
  // Create a modal with instructions
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h2>Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§</h2>
        <button class="modal-close" id="closeServiceHelp">&times;</button>
      </div>
      <div class="modal-body">
        <p>Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ±ØŒ Ø¨Ø§ÛŒØ¯ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø±Ø§ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯:</p>
        
        <div class="setting-card">
          <h3>Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªØµÙˆÛŒØ±</h3>
          <p>1. Ù¾Ù†Ø¬Ø±Ù‡ Command Prompt ÛŒØ§ PowerShell Ø¨Ø§Ø² Ú©Ù†ÛŒØ¯</p>
          <p>2. Ø¨Ù‡ Ù…Ø³ÛŒØ± Ø²ÛŒØ± Ø¨Ø±ÙˆÛŒØ¯:</p>
          <code>c:\\Users\\Dani\\Desktop\\pelak\\Sefro_CCTV_AI-main\\packages\\local_app</code>
          <p>3. Ø¯Ø³ØªÙˆØ± Ø²ÛŒØ± Ø±Ø§ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯:</p>
          <code>python enhanced_main.py</code>
          <p>4. Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯ ØªØ§ Ø³Ø±ÙˆÛŒØ³ Ø´Ø±ÙˆØ¹ Ø¨Ù‡ Ú©Ø§Ø± Ú©Ù†Ø¯ (Ù¾ÙˆØ±Øª 8088)</p>
        </div>
        
        <div class="setting-card">
          <h3>Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³Ø±ÙˆÛŒØ³</h3>
          <p>Ø¨Ø¹Ø¯ Ø§Ø² Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙˆØ¶Ø¹ÛŒØª Ø³Ø±ÙˆÛŒØ³ Ø±Ø§ Ø¨Ø§ Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ø¨Ù‡ Ø¢Ø¯Ø±Ø³ Ø²ÛŒØ± Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯:</p>
          <code>http://127.0.0.1:8088/health</code>
          <p>Ø§Ú¯Ø± Ø³Ø±ÙˆÛŒØ³ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ú©Ø§Ø± Ú©Ù†Ø¯ØŒ Ø¨Ø§ÛŒØ¯ Ù¾ÛŒØ§Ù… "healthy" Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯.</p>
        </div>
        
        <div class="text-center mt-lg">
          <button class="btn btn-primary" id="retryServiceCheck">Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¬Ø¯Ø¯ Ø³Ø±ÙˆÛŒØ³</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Add event listeners
  document.getElementById('closeServiceHelp').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  document.getElementById('retryServiceCheck').addEventListener('click', async () => {
    const serviceAvailable = await checkStreamingService();
    if (serviceAvailable) {
      showToast('Ø³Ø±ÙˆÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!', 'success');
      document.body.removeChild(modal);
    } else {
      showToast('Ø³Ø±ÙˆÛŒØ³ Ù‡Ù†ÙˆØ² Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ù…Ø±Ø§Ø­Ù„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.', 'error');
    }
  });
  
  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// Show service status in UI
async function updateServiceStatus() {
  const serviceAvailable = await checkStreamingService();
  
  // Update any service status indicators in the UI
  const serviceStatusElements = document.querySelectorAll('.service-status');
  serviceStatusElements.forEach(element => {
    if (serviceAvailable) {
      element.textContent = 'Ø³Ø±ÙˆÛŒØ³ ÙØ¹Ø§Ù„';
      element.className = 'status-indicator connected';
    } else {
      element.textContent = 'Ø³Ø±ÙˆÛŒØ³ ØºÛŒØ±ÙØ¹Ø§Ù„';
      element.className = 'status-indicator warning';
    }
  });
  
  return serviceAvailable;
}

// Remove stream from live view
function removeStream(cameraId) {
  console.log('Removing stream for camera:', cameraId);
  
  try {
    // Remove from discovered cameras
    state.discoveredCameras = state.discoveredCameras.filter(c => c.id !== cameraId);
    localStorage.setItem('discoveredCameras', JSON.stringify(state.discoveredCameras));
    
    // Stop any running streams
    if (state.streamIntervals && state.streamIntervals[cameraId]) {
      clearInterval(state.streamIntervals[cameraId]);
      delete state.streamIntervals[cameraId];
    }
    
    // Update the view
    if (state.currentPage === 'livestream') {
      updateLiveStreamView();
    }
    
    showToast('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø­Ø°Ù Ø´Ø¯', 'success');
  } catch (error) {
    console.error('Error removing stream:', error);
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯ÙˆØ±Ø¨ÛŒÙ†', 'error');
  }
}

// Copy to clipboard utility
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Ú©Ù¾ÛŒ Ø´Ø¯', 'success');
  }).catch(() => {
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ', 'error');
  });
}

function formatTime(timestamp) {
  if (!timestamp) return 'Ù†Ø§Ù…Ø´Ø®Øµ';
  const date = new Date(timestamp);
  return date.toLocaleTimeString('fa-IR');
}

function formatDateTime(timestamp) {
  if (!timestamp) return 'Ù†Ø§Ù…Ø´Ø®Øµ';
  const date = new Date(timestamp);
  return date.toLocaleString('fa-IR');
}

// Show manual add stream modal
function showManualAddStreamModal() {
  // Create a modal with manual add form
  const modal = document.createElement('div');
  modal.className = 'modal active manual-add-modal';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h2><i class="fas fa-plus-circle"></i> Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯Ø³ØªÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ†</h2>
        <button class="modal-close" id="closeManualAddModal">&times;</button>
      </div>
      <div class="modal-body">
        <form class="manual-add-form" id="manualAddForm">
          <div class="form-group">
            <label class="form-label">Ù†Ø§Ù… Ø¯ÙˆØ±Ø¨ÛŒÙ†</label>
            <input type="text" id="manualCameraName" class="form-input" placeholder="Ù…Ø«Ø§Ù„: Ø¯ÙˆØ±Ø¨ÛŒÙ† ÙˆØ±ÙˆØ¯ÛŒ" required>
          </div>
          
          <div class="form-group">
            <label class="form-label">Ø¢Ø¯Ø±Ø³ RTSP</label>
            <input type="text" id="manualRtspUrl" class="form-input" placeholder="rtsp://username:password@ip:port/path" required>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label class="form-label">Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ</label>
              <input type="text" id="manualUsername" class="form-input" placeholder="admin">
            </div>
            
            <div class="form-group">
              <label class="form-label">Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±</label>
              <input type="password" id="manualPassword" class="form-input" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢">
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Ø¨Ø±Ù†Ø¯ Ø¯ÙˆØ±Ø¨ÛŒÙ†</label>
            <select id="manualCameraBrand" class="form-select">
              <option value="generic">Ø¹Ù…ÙˆÙ…ÛŒ</option>
              <option value="reolink">Reolink</option>
              <option value="hikvision">Hikvision</option>
              <option value="dahua">Dahua</option>
            </select>
          </div>
          
          <div class="form-group text-center">
            <button type="submit" class="btn btn-primary btn-large">
              <i class="fas fa-plus"></i> Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ†
            </button>
          </div>
        </form>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Add event listeners
  document.getElementById('closeManualAddModal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  document.getElementById('manualAddForm').addEventListener('submit', function(e) {
    e.preventDefault();
    handleManualAddStream();
  });
  
  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// Handle manual add stream
function handleManualAddStream() {
  const cameraName = document.getElementById('manualCameraName').value;
  const rtspUrl = document.getElementById('manualRtspUrl').value;
  const username = document.getElementById('manualUsername').value;
  const password = document.getElementById('manualPassword').value;
  const brand = document.getElementById('manualCameraBrand').value;
  
  // Validate inputs
  if (!cameraName || !rtspUrl) {
    showToast('Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø¯ÙˆØ±Ø¨ÛŒÙ† Ùˆ Ø¢Ø¯Ø±Ø³ RTSP Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯', 'error');
    return;
  }
  
  // Construct full RTSP URL if needed
  let fullRtspUrl = rtspUrl;
  if (username && password && rtspUrl.includes('@') === false) {
    // Add credentials to URL
    const urlParts = rtspUrl.split('://');
    if (urlParts.length === 2) {
      fullRtspUrl = `${urlParts[0]}://${username}:${password}@${urlParts[1]}`;
    }
  }
  
  // Generate a unique ID for the stream
  const streamId = 'stream_' + Date.now();
  
  // Extract camera info from URL
  const cameraInfo = {
    id: streamId,
    url: fullRtspUrl,
    name: cameraName,
    addedAt: new Date().toISOString()
  };

  // Add to discovered cameras
  state.discoveredCameras.push(cameraInfo);
  localStorage.setItem('discoveredCameras', JSON.stringify(state.discoveredCameras));

  // Close modal
  const modal = document.querySelector('.manual-add-modal');
  if (modal) {
    document.body.removeChild(modal);
  }

  // Update the view
  updateLiveStreamView();
  
  showToast(`Ø¯ÙˆØ±Ø¨ÛŒÙ† "${cameraName}" Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯`, 'success');
}

// Capture snapshot from stream
function captureSnapshot(cameraId) {
  const canvasElement = document.getElementById(`stream-${cameraId}`);
  if (!canvasElement || !canvasElement.currentImage) {
    showToast('Ù‡ÛŒÚ† ØªØµÙˆÛŒØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ø¹Ú©Ø³ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯', 'warning');
    return;
  }
  
  try {
    // Create a temporary canvas to capture the current frame
    const tempCanvas = document.createElement('canvas');
    const ctx = tempCanvas.getContext('2d');
    
    // Set dimensions to match the current image
    tempCanvas.width = canvasElement.currentImage.width;
    tempCanvas.height = canvasElement.currentImage.height;
    
    // Draw the current image
    ctx.drawImage(canvasElement.currentImage, 0, 0);
    
    // Convert to blob and download
    tempCanvas.toBlob(function(blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `snapshot_${cameraId}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast('Ø¹Ú©Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯', 'success');
    }, 'image/png');
  } catch (error) {
    console.error('Error capturing snapshot:', error);
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø¹Ú©Ø³: ' + error.message, 'error');
  }
}

// Show stream info
function showStreamInfo(cameraId) {
  const camera = state.discoveredCameras.find(c => c.id === cameraId);
  if (!camera) {
    showToast('Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯ÙˆØ±Ø¨ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯', 'error');
    return;
  }
  
  // Create info modal
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h2><i class="fas fa-info-circle"></i> Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯ÙˆØ±Ø¨ÛŒÙ†</h2>
        <button class="modal-close" id="closeStreamInfoModal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="setting-card">
          <h3>Ø¬Ø²Ø¦ÛŒØ§Øª Ø¯ÙˆØ±Ø¨ÛŒÙ†</h3>
          <div class="stream-info-details">
            <p><strong>Ù†Ø§Ù… Ø¯ÙˆØ±Ø¨ÛŒÙ†:</strong> ${camera.name}</p>
            <p><strong>Ø¢Ø¯Ø±Ø³ RTSP:</strong> ${camera.url}</p>
            <p><strong>ØªØ§Ø±ÛŒØ® Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù†:</strong> ${new Date(camera.addedAt).toLocaleString('fa-IR')}</p>
            <p><strong>Ø´Ù†Ø§Ø³Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†:</strong> ${camera.id}</p>
          </div>
        </div>
        
        <div class="setting-card">
          <h3>Ø¹Ù…Ù„ÛŒØ§Øª</h3>
          <div class="stream-actions">
            <button class="btn btn-secondary" onclick="copyToClipboard('${camera.url}')">
              <i class="fas fa-copy"></i> Ú©Ù¾ÛŒ Ø¢Ø¯Ø±Ø³ RTSP
            </button>
            <button class="btn btn-secondary" onclick="removeStream('${camera.id}')">
              <i class="fas fa-trash"></i> Ø­Ø°Ù Ø¯ÙˆØ±Ø¨ÛŒÙ†
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Add event listeners
  document.getElementById('closeStreamInfoModal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// Copy text to clipboard
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showToast('Ø¢Ø¯Ø±Ø³ RTSP Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ù¾ÛŒ Ø´Ø¯', 'success');
  }).catch(err => {
    showToast('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ø¢Ø¯Ø±Ø³: ' + err.message, 'error');
  });
}

// Toggle fullscreen stream
function toggleFullscreenStream(cameraId) {
  const streamContainer = document.getElementById(`stream-${cameraId}`).closest('.stream-item');
  if (!streamContainer) return;
  
  if (streamContainer.classList.contains('fullscreen')) {
    // Exit fullscreen
    streamContainer.classList.remove('fullscreen');
    document.body.classList.remove('fullscreen-active');
  } else {
    // Enter fullscreen
    streamContainer.classList.add('fullscreen');
    document.body.classList.add('fullscreen-active');
  }
}

// Add fullscreen styles dynamically
function addFullscreenStyles() {
  const style = document.createElement('style');
  style.textContent = `
    .stream-item.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10000;
      margin: 0;
      border-radius: 0;
    }
    
    .stream-item.fullscreen .stream-video-container {
      padding-top: 0;
      height: calc(100% - 120px);
    }
    
    .stream-item.fullscreen .stream-video-wrapper {
      position: static;
      height: 100%;
    }
    
    .stream-item.fullscreen .live-stream-canvas {
      height: 100%;
      border-radius: 0;
    }
    
    body.fullscreen-active {
      overflow: hidden;
    }
    
    .stream-item.fullscreen .stream-header-actions .btn-small:first-child i::before {
      content: "\\f066";
    }
  `;
  document.head.appendChild(style);
}

// Add fullscreen styles when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  addFullscreenStyles();
});

// Remove stream function (updated)
function removeStream(cameraId) {
  // Stop the stream if it's running
  stopStream(cameraId);
  
  // Remove from state
  state.discoveredCameras = state.discoveredCameras.filter(camera => camera.id !== cameraId);
  localStorage.setItem('discoveredCameras', JSON.stringify(state.discoveredCameras));
  
  // Update the view
  updateLiveStreamView();
  
  showToast('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯', 'success');
}

}  
 